// Generated by CoffeeScript 1.6.3
var define;

define = (function(root) {
  var require;
  if (typeof root.define === 'function' && root.define.amd) {
    return define;
  } else {
    require = function(dep) {
      return (function() {
        var _ref;
        switch (dep) {
          case 'underscore':
            return root._;
          case 'jquery':
            return root.jQuery;
          case 'ribcage/views/base':
            return root.ribcage.views.baseView;
          case '../gmaps':
            return (_ref = root.google) != null ? _ref.maps : void 0;
          default:
            return null;
        }
      })() || (function() {
        throw new Error("Unmet dependency " + dep);
      })();
    };
    return function(factory) {
      var module;
      module = factory(require);
      root.ribcageGoogleMaps.views.streetView = module;
      root.ribcageGoogleMaps.views.StreetView = module.View;
      return root.ribcageGoogleMaps.viewMixins.StreetView = module.mixin;
    };
  }
})(this);

define(function(require) {
  var BaseView, DEGREES_PER_RADIAN, RADIANS_PER_DEGREE, StreetView, clone, maps, streetViewMixin, svService, type, _, _ref;
  _ = require('underscore');
  _ref = require('dahelpers'), type = _ref.type, clone = _ref.clone;
  BaseView = require('ribcage/views/base').View;
  maps = require('../gmaps');
  svService = new google.maps.StreetViewService();
  DEGREES_PER_RADIAN = 57.2957795;
  RADIANS_PER_DEGREE = 0.017453;
  streetViewMixin = {
    template: '',
    streetViewContainer: null,
    visible: true,
    streetViewDefaultUI: true,
    streetViewWheel: true,
    maxSearchRadius: 50,
    ignoreHeading: false,
    defaultHeading: 0,
    streetViewAddressControl: true,
    streetViewClickToGo: true,
    streetViewDblClickZoom: false,
    streetViewCloseButton: false,
    streetViewImageDates: false,
    streetViewLinks: false,
    streetViewPanControl: false,
    streetViewZoomControl: null,
    streetViewZoomControlStyle: null,
    getTrueHeading: function(target, actual) {
      var deltaLat, deltaLong, lat, long, targetLat, targetLong, yaw;
      targetLat = target.lat();
      targetLong = target.lng();
      lat = actual.lat();
      long = actual.lng();
      if (targetLat === lat && targetLong === long) {
        return this.defaultHeading;
      }
      deltaLat = targetLat - lat;
      deltaLong = targetLong - long;
      yaw = Math.atan2(deltaLong * Math.cos(targetLat * RADIANS_PER_DEGREE), deltaLat) * DEGREES_PER_RADIAN;
      if ((0 < yaw && yaw < 360)) {
        return yaw;
      }
      if (yaw < 0) {
        return yaw + 360;
      } else {
        return yaw - 360;
      }
    },
    getCtrlPos: function(v) {
      if ((v == null) || (v === true || v === false)) {
        return void 0;
      }
      return maps.ControlPosition[v.toUpperCase()];
    },
    getZoomCtrlStyle: function(v) {
      v = v == null ? 'DEFAULT' : v.toUpperCase();
      return maps.ZoomControlStyle[v];
    },
    getStreetViewContainer: function() {
      var svContainer;
      if (this.streetViewContainer == null) {
        return this.el;
      }
      svContainer = this.$(this.streetViewContainer);
      if (svContainer.length) {
        return svContainer[0];
      } else {
        return this.el;
      }
    },
    getStreetViewOpts: function(cfg, data) {
      var o, _fn, _i, _len, _ref1,
        _this = this;
      if (cfg == null) {
        cfg = {};
      }
      _ref1 = ['streetViewDefaultUI', 'streetViewWheel', 'streetViewAddressControl', 'streetViewClickToGo', 'streetViewDblClickZoom', 'streetViewCloseButton', 'streetViewImageDates', 'streetViewLinks', 'streetViewPanControl', 'streetViewZoomControl', 'streetViewZoomControlStyle'];
      _fn = function(o) {
        if (cfg[o] == null) {
          return cfg[o] = _this[o];
        }
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        o = _ref1[_i];
        _fn(o);
      }
      return {
        pov: {
          heading: data.heading(),
          pitch: data.pitch()
        },
        position: data.coords(),
        addressControl: !!cfg.streetViewAddressControl,
        addressControlOptions: {
          position: this.getCtrlPos(cfg.streetViewAddressControl)
        },
        clickToGo: cfg.streetViewClickToGo,
        disableDefaultUI: !cfg.streetViewDefaultUI,
        disableDoubleClickZoom: !cfg.streetViewDblClickZoom,
        enableCloseButton: cfg.streetViewCloseButton,
        imageDateControl: cfg.streetViewImageDates,
        linksControl: cfg.streetViewLinks,
        panControl: !!cfg.streetViewPanControl,
        panControlOptions: {
          position: this.getCtrlPos(cfg.streetViewPanControl)
        },
        scrollWheel: cfg.streetViewWheel,
        visible: false,
        zoomControl: !!cfg.streetViewZoomControl,
        zoomControlOptions: {
          position: this.getCtrlPos(cfg.streetViewZoomControl),
          style: this.getZoomCtrlStyle(cfg.streetViewZoomControlStyle)
        }
      };
    },
    initialize: function(_arg) {
      this.svExtraConfigs = _arg.svExtraConfigs;
    },
    noStreetView: function(config, callback) {
      alert("Street view data is not available for this location");
      if (callback != null) {
        return callback(this, this.panorama, config);
      }
    },
    beforeRender: function(config, renderCallback, callback) {
      var pos, radius,
        _this = this;
      pos = config.position;
      radius = this.maxSearchRadius;
      return svService.getPanoramaByLocation(pos, radius, function(data, status) {
        if (status !== maps.StreetViewStatus.OK) {
          return _this.noStreetView(config, renderCallback);
        }
        return callback(data);
      });
    },
    render: function(cb) {
      var svCfg, svContainer,
        _this = this;
      if (this.panorama) {
        return;
      }
      this.$el.html(type(this.template, 'function') ? this.template() : this.template);
      if (this.panorama) {
        return;
      }
      svContainer = this.getStreetViewContainer();
      svCfg = this.getStreetViewOpts(this.svExtraConfigs, this.model);
      this.beforeRender(svCfg, cb, function(data) {
        var actualLoc, heading;
        _this.panorama = new maps.StreetViewPanorama(svContainer, svCfg);
        _this.panorama.setPano(data.location.pano);
        if (_this.ignoreHeading) {
          actualLoc = data.location.latLng;
          heading = _this.getTrueHeading(svCfg.position, data.location.latLng);
          _this.panorama.setPov({
            heading: heading,
            pitch: 0
          });
        }
        _this.panorama.setVisible(_this.visible);
        if (type(cb, 'function')) {
          return cb(_this, _this.panorama, svCfg);
        }
      });
      return this;
    }
  };
  StreetView = BaseView.extend(streetViewMixin);
  return {
    mixin: streetViewMixin,
    View: StreetView
  };
});
